<!DOCTYPE html>
<html lang="en">
<head>
	<link rel="stylesheet" type="text/less" href="/css/post.less">
	
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="shortcut icon" type="image/png" href="/img/cat.jpg"/>
	<script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/less.js/2.5.3/less.min.js"></script>
	<link href="https://fonts.googleapis.com/css?family=Roboto:400,700" rel="stylesheet">
	<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-58440568-4', 'auto');
		ga('send', 'pageview');
	</script>

	<!-- Cookie Consent plugin by Silktide - http://silktide.com/cookieconsent -->
	<script type="text/javascript">
    window.cookieconsent_options = {"message":"This website uses cookies to ensure you get the best experience on our website","dismiss":"Got it!","learnMore":"More info","link":null,"theme":"dark-bottom"};
	</script>
	<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/1.0.10/cookieconsent.min.js"></script>
	<title>ELI5: How did the first programmers program programs? For example, how did they program the Operating System or CMD if they had no programs or programming languages.</title>
</head>
<body>
	<div id="header">
	<a href="/about" title="About">About</a>
</div>
	<div id="content">
		<div class="home">
			<a href="/">Back to Home</a>
		</div>

		<ul class="posts">
<li class="post" data-handle="5ubdlv">
	<div class="overview">
		<a class="source" href="https://www.reddit.com/r/explainlikeimfive/comments/5ubdlv/eli5_how_did_the_first_programmers_program/" target="_blank" title="Reddit thread where this comes from"><i class="fa fa-external-link" aria-hidden="true"></i></a>
		<h2>
			<a href="/posts/5ubdlv" onclick="return false">How did the first programmers program programs? For example, how did they program the Operating System or CMD if they had no programs or programming languages.</a>
		</h2>
		<!--<span class="date">2017-02-19</span>-->
		<span class="is-new">NEW</span>
	</div>

		<div class="question"><span class="qa" title="Question">Q:</span><div class="markdown"><p>ELI5: How did the first programmers program programs? For example, how did they program the Operating System or CMD if they had no programs or programming languages.</p></div></div>

	<div class="comment-section">
		<div class="answers-placeholder">
			<div class="answers">
	<div class="answer" data-handle="ddt4x4l">
		<a class="author" href="https://www.reddit.com/user/lol_admins_are_dumb" target="_blank">lol_admins_are_dumb</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>How do you mass produce tools? First, you sort of cobble a tool together using whatever you've got. Then you have your proto-tools, you use those to bootstrap yourself up to the next level, hand-crafting your nice tools. Ok, now you have some actual tools, but you still haven't gotten mass-production. So you use your nice tools to build some tool-building tools, and then once you have those, you build some tool-building-tool-weilding automation systems (you could call them robots, or factory lines, depending which era you're talking about). And so on.</p>
<p>It's basically just bootstrapping again and again and again. Somebody took the first circuits and said &quot;if I connect these two wires in this way, I get this output&quot;. Somebody else said &quot;well let me take some circuit boards and print them in such a way that it's easy to switch the inputs around to get different outputs&quot;. Then somebody said &quot;cool, now that you have that, I'm going to come up with a set of common rules on how best to get a certain output using these circuit paths. As long as your circuit machines follow this convention, other people can quickly bang out circuits using that same convention without having to build it from scratch every time&quot;. That's assembly. Then somebody else said &quot;ok cool, but some people don't really understand circuits, so I'm going to abstract that one level further&quot;.</p>
<p>If you are a programmer, any time you abstract some concept into an easier to use API, you are doing the exact same sort of process the early programmers were doing. They just didn't have so many shoulders to stand on as you do. When I write fetch('/foo').then(r =&gt; r.text()).then(console.log.bind(console)), I am not actually thinking about all the various pieces that breaks down into. But somebody else at some point said &quot;you know what, javascript needs a way to make http requests&quot;. And somebody before them said &quot;you know what, there should be a quick and easy way to make a standardized tcp connection to a server, receive some data, and close the connection&quot;. Somebody before that said &quot;I wish there were a protocol that would help me send packets of data across a network in a standardized way&quot;. Before that somebody said &quot;I wish there were some way to beam bits of light across ethernet cables&quot;. etc.</p>
<p>Obviously take these generalizations with a grain of salt, I'm sort of making it up to prove a point.</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
	<a class="less-answers upper" href="javascript:void(0)">less answers...</a>
	<div class="answer" data-handle="ddt6tor">
		<a class="author" href="https://www.reddit.com/user/duhcartmahn2" target="_blank">duhcartmahn2</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>I am enjoying this topic, so let me try my hand at explaining it.</p>
<hr />
<p>First, you must understand that a computer is essentially a really complicated series of switches.  Each switch does something specific with a bit (1 or 0).  Flipping a switch may send a bit to one place or another.  A different switch may save that bit for later.  Yet another switch may flip a series of other switches which all preform a more complicated action like binary multiplication.  It may even do something really fancy, like light up a pixel on an external display.</p>
<p>As you can imagine, a computer has a lot of these switches in the processor.  Millions or billions of them in fact.  Basically, way too many to set individually.  So, when we design a chip, we make a few switches that control all the rest of them.  We call this an instruction.</p>
<p>An instruction for a simple processor may just be 8 bits, something like '11001100' which means we turn on the 3rd, 4th, 7th, and 8th switches, while leaving the others off.  When you use the switches this way, it may cause a cascading action that adds two bits together, and outputs the result.  Now that there are easier instructions, users can just input the instructions that they want the computer to run, one at a time!  This is effectively a language, called machine code.  Old-school processors came with a thick book of instruction decodes (Add A to B is 11010001), and you would have to run it that way.</p>
<p>Okay, so users can put in one command at a time.  Too Slow!  So what we do is save commonly used commands that handle standard tasks, such as reading a keyboard press, displaying text on a screen, or reading a harddrive.  All these simple tasks can be saved to a memory chip that runs the moment we press the power button, and continues running as long as the computer is on.  So that way, it knows when you press the keyboard for example.</p>
<p>But still, no person programs in machine code these days.  Instead, we abstract that by making a language that is easier to read and write.  Something like C, or Python.  So what we do is write code in those languages, and then another program turns that language into the machine code that runs the computer.  </p>
<hr />
<p>TL;DR - Basic tasks that are necessary to get a computer to a point where you can program it are hard coded 1s and 0s that drive the transistors in your processor to a state where you can load more complicated code.</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
	<div class="answer" data-handle="ddswn76">
		<a class="author" href="https://www.reddit.com/user/hblask" target="_blank">hblask</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>Step 1: Build a computer that can only be programmed by physically moving wires around to change the patterns of 1's and 0's.</p>
<p>Step 2: Get sick of that, so create a computer that can read those ones and zeros off a physical medium, such as a long strip of paper, or cards.   This is called programming in &quot;Machine Language&quot;.</p>
<p>Step 3: Get sick of writing ones and zeros for the commands, so give names to the various opcodes, such as &quot;LSR&quot;, for Left Shift Register.   This is called &quot;Assembly Language&quot;.   Write a program that does a 1 to 1 translation of assembly command to machine command.</p>
<p>Step 4: Realize that you keep doing the same sequence of assembly language instructions over and over, so you create a program that can convert a special command, such as &quot;loop X times&quot; into that sequence of assembly language commands.</p>
<p>Step 5: Keep adding more commands, and realize that symbolic addresses are useful, too.   Before you know it, you have a compiler for a high level language, written in assembly language.</p>
<p>Step 6: Do future iterations of this process in the higher language to build even higher level languages. </p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
	<div class="answer" data-handle="ddsvqo5">
		<a class="author" href="https://www.reddit.com/user/Fenrir101" target="_blank">Fenrir101</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>The operating systems, and compilers are all there to make life easier. As a child I had a z80 computer which came as a box of components and a circuit diagram. The input was three banks of buttons one (8 button bank) for the byte, one for the address and a small number of functions like write memory, show memory, run program and the like. To write a program for this monster I would get a piece of paper and work out what i wanted it to do. I would then write (by hand) the machine code instructions and then refer to another sheet of paper with the binary equivalents for each instruction. </p>
<p>I then used some graph paper on which i had columns for memory address, op code (the command) and the data, all written as 1's and 0's. I would then use the keyboard to enter the memory address (in binary) and the command or data i wanted to enter. After many hours I would then hit the run button and watch as the bank of 8 Light bulbs would flicker in a set sequence, and have to start all over again as the computer had no long term memory.</p>
<p>Earlier than that, NASA and other organisaitons used &quot;braid memory&quot; which is literally bundles of wires braided together into the binary patterns for the program to be run. This means that rocket's flew into space running computer programs entered into them by little old ladies basically knitting miles and miles of wire. (<a href="https://en.wikipedia.org/wiki/Core_rope_memory" target="_blank">https://en.wikipedia.org/wiki/Core_rope_memory</a>)</p>
<p>And even earlier than that the Bombe (a code breaking computer from 1939) had rotating switches for memory, you programmed it by turning dials for each memory location before running it. Although the bombe was only capable of running one &quot;program&quot; without physically re-building it, and the memory was more like a saved configuration file for that program in today's terms.</p></div>		<div class="replies-placeholder"></div>
	</div>
	<div class="answer" data-handle="ddstjq5">
		<a class="author" href="https://www.reddit.com/user/Psychofant" target="_blank">Psychofant</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>Are you asking us how programmers programmed programs when they didn't have any programming programs to program programs with?</p>
<p>If you look at the predecessor to Windows, MS-DOS, you will notice how simple it is, and how little it could do. So somebody wrote compilers for it, which allowed people to write more complex programs for it. Then people wrote graphical Software Development Kits, and slowly the beast just grew and grew. What was important here was the fact that everyone settled on using the same computer - what was known as the IBM-compatible, or as it's called today: The PC.</p>
<p>I had an 8-bit machine back in the eighties, and we could buy magazines with programs to enter. It would come in the shape of a page of machine code, and a tiny BASIC program that you could enter the machine code into in order to write it to disk. Oh, yeah, and if you got any of the bytes wrong, you'd just crash and would essentially have to start over. I'd say &quot;Good times&quot;, but damn it, it wasn't.</p>
<p>The 8-bit processor would itself come with a ROM - read-only-memory, which would provide basic functionality. To the best of my knowledge, this was actually hardware. As in, the programs were written with logic gates. I did have a PASCAL compiler back in the mid-eighties, but the compiler itself took up most of the disc space itself, so you couldn't really do much with it. :p</p>
<p>TL;DR: With logic gates and machine code. And very slowly.</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
</div>		</div>
		<div class="more-less">
			<a class="collapse" href="javascript:void(0)">collapse</a>
			<a class="more-answers" href="javascript:void(0)">4 more answers...</a>
			<a class="less-answers lower" href="javascript:void(0)">less answers...</a>
			&nbsp;
		</div>
	</div>
	<a class="show" href="/posts/5ubdlv" onclick="return false"><span>show</span></a>
</li>
		</ul>
	</div>

	<script>
		var config = {"stream":{"initial":10,"catchup":5},"api":{"url":"api.veryinteresting.io"}};
	</script>
	<script src="/js/project.js"></script>
	<script src="/js/post.js"></script>
</body>
</html>