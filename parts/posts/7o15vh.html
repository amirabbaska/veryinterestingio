<li class="post" data-handle="7o15vh">
	<div class="overview">
		<a class="source" href="https://www.reddit.com/r/askscience/comments/7o15vh/how_does_speculative_execution_in_cpus_work/" target="_blank" title="Reddit thread where this comes from"><i class="fa fa-external-link" aria-hidden="true"></i></a>
		<h2>
			<span class="tags tag-Engineering">Engineering</span>
			<a href="/posts/7o15vh" onclick="return false">How does speculative execution in CPUs work?</a>
		</h2>
		<!--<span class="date">2018-01-07</span>-->
		<span class="is-new">NEW</span>
	</div>

		<div class="question"><span class="qa" title="Question">Q:</span><div class="markdown"><p>&quot;Speculative execution&quot; in CPUs has been mentioned in the news recently due to the Intel bug.  What operations can be speculatively executed at the CPU level and how does the processor know it has a likelihood of a speedup without any higher level understanding of the problem it is solving?</p></div></div>

	<div class="comment-section">
		<div class="answers-placeholder">
			<div class="answers">
	<div class="answer" data-handle="ds65tf6">
		<a class="author" href="https://www.reddit.com/user/mfb-" target="_blank">mfb-</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>Let’s start with pipelines: Traditionally you would expect a CPU to execute one command, then the next command, and so on, one command per clock cycle. Unfortunately this would need very low CPU speeds. To get faster speeds pipelines were introduced: During one clock cycle only parts of the command are done and the intermediate state is saved, during the next cycle this intermediate state is passed on to the next stage, meanwhile the next command starts already. A simple pipeline might just have 3-4 steps, modern CPUs have many more. There are two cases where this leads to problems:</p>
<ul>
<li>a command needs the result of a previous command that is still in the pipeline</li>
<li>the program logic depends on the outcome of a command: “if x&gt;5 do this else do that”</li>
</ul>
<p>The first case can be reduced by software that makes sure these dependencies are not too fast behind each other. For the other case: A CPU could stop executing commands and wait for the condition to be known (here: what is x), but that would take time. Usually these conditions occur in loops, where the outcome is the same many times (x is smaller 99% of the time). A modern CPU has extra logic that makes a best estimate what the result will be (which code to execute next) and start working on the following code. If the prediction turns out to be wrong then the result of this predictive execution has to be discarded. Most elements of modern CPUs are logic to determine what depends on what, what can be done in parallel, how to clean up if the prediction was wrong and so on. A bug there is not too surprising.</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
	<a class="less-answers upper" href="javascript:void(0)">less answers...</a>
	<div class="answer" data-handle="ds8ili9">
		<a class="author" href="https://www.reddit.com/user/rocketsocks" target="_blank">rocketsocks</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>Speculative execution is a type of instruction level parallelism (or ILP). There are many other types of ILP which are automatically exploited by modern CPUs (going back to the original Pentium era and earlier) to provide speedups. For example, operations can be run in a different order than they were coded in if that is more efficient and still leads to correct program behavior. This sort of thing is important because a CPU has many different sub-components, and maximum performance occurs when more of them are functioning simultaneously, additionally some instructions, like memory operations, can take a very long time compared to others.</p>
<p>Let's say you have a bunch of completely independent instructions in a row in a program, to the processor this is just a pile of instructions, they can all be executed in any order and the result will be the same, so the processor can just sort of &quot;tetris&quot; all of the instructions into the CPU hardware based on whatever is available at any given time and achieve a high level of utilization. Now, if you have a conditional branching instruction in the set then all of that goes out the window. You have to perform all of the instructions which produce the value used to determine the condition before you execute the code after that condition. That means you have to wait to feed instructions to the CPU so it'll spend more time with more of its hardware sitting idle.</p>
<p>However, that's the worst case performance, with speculative execution and branch prediction you can improve the average case performance. What the processor can do is use a heuristic to guess how a conditional will evaluate and then execute the code for that ahead of actually knowing the value involved. Then when the value is actually produced the results of that speculative execution are either made real or they are invalidated and the processor pretends it never happened. In the cases where the branch prediction is right there is a massive speedup, in the case where it's wrong there's actually a little performance hit (due to the work of invalidating the speculative execution results) but in the average case, dependent on the accuracy of the branch prediction, there is a significant net speedup. As a typical example, consider a typical loop where some operation is being iterated many times, the CPU will predict that the loop will just keep running, and will basically speculatively execute future iterations of the loop before they &quot;actually&quot; happen, so for each iteration of the loop it will realize a speedup, and only on exiting the loop (which happens only once after many iterations) does it incur a small performance hit, the net result is a significant overall speedup.</p>
<p>But this behavior, as implemented by most CPUs, has some security weaknesses. Think about all of the conditional tests in code running on a computer. Some of those checks are actually security related, such as buffer lengths, memory space restrictions, and so on. If you can execute code speculatively then you can execute code independent of the security boundaries the operating system wants to impose on running code (which includes, say, javascript running in a browser). In principle this shouldn't matter because the results of speculatively executed code that shouldn't have run get invalidated by the CPU but there are some cracks in that facade. For one, CPUs don't necessarily do a perfect job of cleaning up all of the results of speculatively executed code, specifically changes to the cache. If there are other vulnerabilities in the CPU design that enable accessing cache values then you can force code to execute speculatively then gain access to the values in the cache that have been modified by that code, and thus gain access to data that the OS would otherwise have prevented you from accessing (which might include all manner of data including passwords, encryption keys, details of kernel memory layout that could help with executing other exploits to gain root access, etc.)</p>
<p>Worse yet, even without <em>that</em> vulnerability there is still a timing vulnerability. Let's say you can't gain access to cache data from invalidated speculatively executed instructions. Imagine instead that you are able to force speculative execution of a set of instructions which accesses a single byte of some otherwise privileged memory location <em>as well as comparison operations guessing the value of that memory location</em>. All of these will run speculatively and all of the results will be invalidated, but the amount of time spent running those speculative instructions will differ depending on whether or not the guess was correct. And this sort of timing information makes it possible to run &quot;guess and check&quot; operations against memory, which could simply run through every single bit on every single byte in vulnerable memory. (Think of it like playing a game of 20 questions, except the answerer doesn't want you to know the secret so they always say no, but when the answer is actually yes they say no quickly, when the answer is actually no they pause for a while then say no, you still have enough information to know the truth. And instead of 20 questions you have infinity questions, which you can ask at a frequency of, literally, a billion times a second.) That sort of attack is very hard to protect against with current CPU architectures. The way that folks are trying to mitigate against these attacks is to basically forestall some instructions from the opportunity to be run speculatively as well as to make it more difficult to obtain the sort of high precision timing data that would be necessary to exploit these vulnerabilities in practice, but that is not a perfect fix, more of just a hardening.</p></div>		<div class="replies-placeholder"></div>
	</div>
</div>		</div>
		<div class="more-less">
			<a class="collapse" href="javascript:void(0)">collapse</a>
			<a class="more-answers" href="javascript:void(0)">1 more answer...</a>
			<a class="less-answers lower" href="javascript:void(0)">less answers...</a>
			&nbsp;
		</div>
	</div>
	<a class="show" href="/posts/7o15vh" onclick="return false"><span>show</span></a>
</li>
