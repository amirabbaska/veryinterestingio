	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/tuseroni" target="_blank">tuseroni</a>
			<div class="markdown"><p>thankfully the unix y2k is fixed with 64 bit timestamps, those will be good up until the year 584,542,048,061 i'm sure we will have better than 64 bit systems by then...if we are still around.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/BecauseEricHasOne" target="_blank">BecauseEricHasOne</a>
			<div class="markdown"><p>Can you explain what you mean? </p>
<p>&quot;At some point people realized that the programs written in decades past were still around and that computers that used this method would still be around by the years 2000 and that this might cause them to act as if they were a hundred years in the past and cause all sorts of bugs.&quot;</p>
<p>What bugs would it cause?</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Usgarden" target="_blank">Usgarden</a>
			<div class="markdown"><p>Alan works x number of hours in a week.  The week is calculated using the current day - 7.  On the 27/12/1999, this works fine as the database query comes up with dates between 20/12/1999 and 27/12/1999.  The following week, the computer calculates Alan's pay between 27/12/1899 (or 1999?) and 03/01/1900.  Alan doesn't get paid, or he gets paid A LOT.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Loki-L" target="_blank">Loki-L</a>
			<div class="markdown"><p>Well the simplest would be simply displaying the wrong date in a lot of places: A mostly cosmetic bug.</p>
<p>More worrisome would be using the bad date in calculations and comparisons. Banks computers could for example determine that it has been almost a century since somebody last paid anything on a mortgage and initiate foreclosure or similar stuff.</p>
<p>There were some funny events when centenarians were invited to Kindergarten by automated systems.</p>
<p>The really worrisome problems would have been the ones where the computer decided some rate of change by comparing dates and acting on information that was wildly of because instead of dividing by a second or so it would divided by minus a century. I don't think any embedded systems were stupid enough to calculate for example a vehicles speed that way, but if they did it would be very bad. </p>
<p>Semi related fun fact: The American F-22 military jet was so badly programmed that the board computer crashed every time the plane crossed the international date line. (I think they have since fixed the issue)</p>
<p>All sorts of automated ordering systems managing &quot;just in time&quot; stocks would be completely confused because they wouldn't understand what time it is.</p>
<p>Any systems that simply checked if one date was bigger than another would give the wrong answer if one of those dates was before January 1st and the other was after.</p>
<p>Even worse most of the bad results the computers get by trying to work with these bad dates would be fed into other computer systems, many of which were not Y2K affected themselves but simply had tow work with bad data. In It if you put garbage in you get garbage out. This could have resulted in some very bad grabage all around.</p>
<p>To make things worse a lot of time programmers don't write their programs to be able to handle situations that they think can never happen.</p>
<p>If one of the things that they thought could never happen (such as a large negative number as an input where a small positive one was expected) the results will become undefined and quite possibly bad.</p>
<p>Programs abort with errors they can't handle and systems shut down until somebody fixes them.</p>
<p>The idea that somewhere some computer managing part of the electricity grid would shut down on new years day was a real worry for many.</p>
<p>Luckily almost all the problems were caught before they could shut down the planet.</p></div>		</li>
					</ul>
		</ul>
	