	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Existential_Fluff" target="_blank">Existential_Fluff</a>
			<div class="markdown"><p>That was a really interesting read! I'm pretty sure it went in one eye and out the other but while it was in there, I found it really informative.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/i_build_minds" target="_blank">i_build_minds</a>
			<div class="markdown"><p>You may wish to look into the following terms: (also, /u/The-unreliable-one, good question - here's a bit more)</p>
<ul>
<li>Extrapolator</li>
<li>Avalanche (Cryptography)</li>
<li>Confusion / Diffusion (Cryptography)</li>
</ul>
<p>In my day, credit card generators (extrapolators) were built using similar methods as those described above. The Luhn algorithm nicely bounded the outputs into 4ish chunks about 10k in size. Then the 10k is reduced due to rules involving the checksum, and other aspects. This made it really easy to generate new card numbers -- and is one of the factors in why people have moved to chargebacks and chip and pin.</p>
<p>Avalanche is a concept re: entropy (.50 differential on any input event). Any more or less makes your output predictable. Confusion / Diffusion is related, so was worth mentioning but it's probably better written here than anything I could provide: <a href="https://en.wikipedia.org/wiki/Confusion_and_diffusion" target="_blank">https://en.wikipedia.org/wiki/Confusion_and_diffusion</a></p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/gnzla" target="_blank">gnzla</a>
			<div class="markdown"><p>Man, this is what I love about cryptography. Every time I get comfortable with an algorithm or a concept, I stumble across something new to learn. Thanks for the links! </p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ericGraves" target="_blank">ericGraves</a>
			<div class="markdown"><p>It does not matter if the output is not uniform. You can use privacy amplification to change a string of n values with some arbitrary distribution P, into a nH(P) string with a uniform distribution. </p>
<p>This is essential quantum key distribution when the adversary is observing some of the qubits.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/inFeathers" target="_blank">inFeathers</a>
			<div class="markdown"><p>New favourite saying!! Brilliant. And yes, that was an excellent explanation. </p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Existential_Fluff" target="_blank">Existential_Fluff</a>
			<div class="markdown"><p>Hahaha thanks! I'm glad some people are taking a liking to it. </p>
<p>I like to think that one day I will hear this phrase used in the future and when I tell that person I coined it in 2016, they will never believe me.</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Uberzwerg" target="_blank">Uberzwerg</a>
			<div class="markdown"><blockquote>
<p>one-time-pad, it is an unbreakable means of encryption</p>
</blockquote>
<p>just a tiny note: There is a proof that shows that it is not only unbreakable, but also the ONLY unbreakable mean of encryption.<br />
I have to admit that i never quite understood most of the crypto proofs i had to learn, but that factoid was interesting enough for me.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/NorthernerWuwu" target="_blank">NorthernerWuwu</a>
			<div class="markdown"><p>This comes up occasionally and while true, can be slightly misleading. </p>
<p>OTPs are unbreakable. That's essentially axiomatic given the lack of information flow. The slightly less clear part (it being the ONLY unbreakable means) is really just a way of restating the first point though.</p>
<p>OTPs are unbreakable because there is no information flow between cypher and original. Possessing the encrypted data does not inform regarding the plaintext (other than total data size which can be fixed relatively easily). Therefore, any 'other' unbreakable encryption can be mathematically considered to be a OTP as it must also have no information flow. Math doesn't care about mechanics essentially.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Austernpilz" target="_blank">Austernpilz</a>
			<div class="markdown"><p>A one time pad is a type of Vigenère cipher where the key is as long as the message.</p>
<p>A Vigenère cipher is just a ceasar cipher where one of the 25 alphabets is determined by the letter of the keyword.</p>
<p>Let's say you keyword is &quot;Beetle&quot;. The b at the start of the keyword tells you that the first letter of the message is to be encrypted by using the ceasar alphabet that transcribes A as B.</p>
<p>When using this method, messages can be deciphered because the same keyword is repeated every 6 letters.
When the key is as long as the message (one time pad) there are no patterns, and therefore it cannot be deciphered.</p>
<p>However, this is true only when the key is truly random, which brings us back to the OP. </p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/billybob_dota" target="_blank">billybob_dota</a>
			<div class="markdown"><p>One time pad is basically useless in most situations though because the key is as big as the message you're sending, you need a secure way of sending the key and a key can only be used a single time otherwise the cryptosystem can be easily broken. The only secure way to send the key would be in person, because any other method would be less secure than the one time pad, and you may as well just use the less secure crypto system to send the message as well...  There would be no benefit in using a one time pad if you had to transmit the key using some other crypto system.. The key is just as sensitive as the message because it decrypts the message...</p>
<p>The only way these are really useful is if you establish ahead of time, a list of keys that will be used to communicate. I think some governments actually do this so they can communicate in case of some emergency, but in general the practical applications of this unbreakable one time pad are very limited.. </p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Uberzwerg" target="_blank">Uberzwerg</a>
			<div class="markdown"><p>My prime example is strategic information to battleships with pre-defined keys for one-time usage.  </p>
<p>Give them a few gigabytes of (well defined) noise that is used to decode messages.  </p>
<p>Now that i think of it, in this time and age, it could be used for a lot of things where you have temporary access to exchange the key and need secure transmission afterwards.  </p>
<p>Hell, even car-keys could synchronize a few megabytes of noise with the car while in the ignition lock and have near perfect communication afterwards.<br />
Just transmit the offset within the noise with each activation and sign whatever action you want to transmit with the noise.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/AreYouNotShpongled" target="_blank">AreYouNotShpongled</a>
			<div class="markdown"><blockquote>
<p>the practical applications of this unbreakable one time pad are very limited</p>
</blockquote>
<p>Generally speaking, in WWII Britain and the United States relied on one-time-pad encryption for their secure radio communications, whereas Germany relied on automated encryption (in the form of the Enigma and Lorenz cipher machines). Guess which side regularly read the other side's secret communications throughout the war?</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/moratnz" target="_blank">moratnz</a>
			<div class="markdown"><p>These days it's not dramatically harder to move a couple of terabytes securely than it is to move a couple of hundred characters. So one-time pads are becoming much more feasible, at least for text communication. </p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Tbone990" target="_blank">Tbone990</a>
			<div class="markdown"><p>So is that a yes or a no?</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/linschn" target="_blank">linschn</a>
			<div class="markdown"><p>The mathematical answer is:</p>
<p>Provided that you have unlimited time and resources, you can find any finite algorithm by brute forcing the space of all algorithm until you find one whose output matches perfectly.</p>
<p>The real-world answer is:</p>
<p>Ain't nobody got time for that, the universe will become cold before you even begin to scrape the surface of the search space, but other techniques as mentioned by /u/i_build_minds exist</p>
<p><a href="https://www.reddit.com/r/askscience/comments/56r419/is_it_possible_to_find_the_algorithm_for_a_random/d8ly0o3" target="_blank">https://www.reddit.com/r/askscience/comments/56r419/is_it_possible_to_find_the_algorithm_for_a_random/d8ly0o3</a></p>
<p>and side-channel attacks (such as timing the execution of the algorithm) are much more efficient.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/The_JSQuareD" target="_blank">The_JSQuareD</a>
			<div class="markdown"><p>The mathematical answer only holds if we know the size of the algorithm that we are trying to find (or have some upper bound on it). Otherwise it is trivial to proof that we can never be sure that we have found the right algorithm. (Basically, the two algorithms might differ in the 10th output, or the trillionth output, or the Graham's numberth output, etc., even if they match up until that point.) </p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/fatlizardgoth" target="_blank">fatlizardgoth</a>
			<div class="markdown"><p>So is that a yes or a no?</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/HaPPYDOS" target="_blank">HaPPYDOS</a>
			<div class="markdown"><p>And allow me to add, even one has infinite amount of time to find the algorithm, he didn't do it by studying the output of the original random number generator, which is what OP asked. He just brute-forced it.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ericGraves" target="_blank">ericGraves</a>
			<div class="markdown"><p>Not practically.</p>
<p>If you have true randomness used in the algorithm, no theoretically. </p>
<p>If it is purely a pseudo random number generator, with no restrictions, still no.</p>
<p>If you restrict to a finite set of pseudo rng, yes theoretically.</p>
<p>If you restrict to about 100 or so rng, then yes practically.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Niqhtmarex" target="_blank">Niqhtmarex</a>
			<div class="markdown"><blockquote>
<p>If you have true randomness used in the algorithm, no theoretically.</p>
</blockquote>
<p>Is this possible?</p></div>		</li>
					</ul>
		</ul>
		</ul>
	