	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/alercah" target="_blank">alercah</a>
			<div class="markdown"><p>This is also the lower bound for how much memory you need, because you need O(log(n)) memory to even express the input n.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/EricPostpischil" target="_blank">EricPostpischil</a>
			<div class="markdown"><p>This occurred to me too, but the problem is not formally stated and leaves room for interpretation. For example, suppose the input <em>n</em> is presented on an input tape. The processor itself might never need to contain the entirety of <em>n</em>. Alternately, the computer might simply produce digits one by one (not bothering to count how many) until the user says stop.</p>
<p>If the problem were instead to compute the <em>n</em>^th digit of ⅓, then the computation is simple: If <em>n</em> is positive, produce 0, and, if <em>n</em> is negative, produce 3 (enumerating the digits in correspondence to the power of ten for their position). Thus we see that the fact that <em>n</em> cannot be held in the computer does not prevent us from computing any desired digit of some numbers.</p>
<p>So, a formal proof has to rely on properties of π, not just the amount of space required to express <em>n</em>, or the statement of the problem has to require that <em>n</em> be stored in the computer. The fact that the computer has finite memory means that, after some time, it must repeat states. Therefore, any decimal string it produces must start repeating at some point and hence must represent a rational number. π is irrational, therefore it cannot be produced by a computer with finite memory.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/shiny_thing" target="_blank">shiny_thing</a>
			<div class="markdown"><p>Are you saying that you can't compute the Nth digit of any irrational with finite memory even when N is on an input tape?</p>
<p>This isn't true:</p>
<p>The number X = 0.1101000100000001...</p>
<p>The Nth digit is 1 if N is a power of two, and is 0 otherwise. It's irrational because the subsequences of 0s grow. Given N as input in a binary representation, the Nth digit of X can be computed with a three state DFA.</p>
<p>Edit: I'm used to thinking dealing with binary when talking about cs, but if course this example extends to other bases. The Nth digit is 1 if N is a power of the base, zero otherwise.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/CNoTe820" target="_blank">CNoTe820</a>
			<div class="markdown"><p>Someone recently set the world record for calculating the furthest digit of pi, he's up to the 10 quadrillionth digit. He talks about it on <a href="http://www.karrels.org/pi/" target="_blank">his site</a>.</p>
<p>They used a CUDA cluster at Santa Clara University.  <a href="http://abc7news.com/archive/9467245/" target="_blank">Source</a>.</p>
<p>His slides from the 2013 NVIDIA GPU Technology Conference are <a href="http://www.karrels.org/pi/S3071_EdKarrels.pdf" target="_blank">here</a>.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Mixels" target="_blank">Mixels</a>
			<div class="markdown"><p>Because the value set for <em>n</em> can be anything between 1 and infinity, no finite amount of memory can contain each of all values from the full range of valid values for <em>n</em>. It is therefore not possible to do input a very large value for <em>n</em> into the application (and it's doubly impossible to store that value in memory) without causing a buffer or integer overflow.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/v4vijayakumar" target="_blank">v4vijayakumar</a>
			<div class="markdown"><p>Store big number in a file, and load a small part as and when you need?</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/SmokyDragonDish" target="_blank">SmokyDragonDish</a>
			<div class="markdown"><p>I don't know if this is valid, but I was going to say &quot;probably not&quot; to OP for a slightly different reason, although I could be full of it.</p>
<p>Because OP specified 1MB of &quot;memory&quot; (open to interpretation), you cannot say that this hypothetical computer is Turing Complete (and absolutely not a Turing Machine), because you just set a limit on memory.  And you're dealing with an irrational number, which by definition is infinitely calculable.</p>
<p>Not sure if that makes any sense or I'm blowing smoke.  Been 20 years since I got my Comp Sci degree. </p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/fetchingTurtle" target="_blank">fetchingTurtle</a>
			<div class="markdown"><p>Could you please elaborate on how a memory limitation makes a given computer not Turing Complete?</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/GarthOmSmith" target="_blank">GarthOmSmith</a>
			<div class="markdown"><p>Is there something special about base 16? Is it solely because the algorithm is meant to be on computers or is there something intrinsic to base 16? (That would blow my mind.) Why not base 10, or base 2, or base 1823746?</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/pi_stuff" target="_blank">pi_stuff</a>
			<div class="markdown"><p>It works with any base that is a power of 2, due to the 16^k factor in the <a href="https://en.wikipedia.org/wiki/Bailey%E2%80%93Borwein%E2%80%93Plouffe_formula" target="_blank">BBP formula</a>.  Nobody has yet found a formula that lets you extract digits of pi in base 10 efficiently.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/StrangeConstants" target="_blank">StrangeConstants</a>
			<div class="markdown"><p>In formulas like this, it usually gets more complex as you have other base primes like 5 or 7 guiding the equations. 2 is the most simple, hence the base 2 (convertible to base 16). There is no reason why we couldn't find something in base 5, though it would likely be more complex and take more computing time. </p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/hoseja" target="_blank">hoseja</a>
			<div class="markdown"><p>Does it work by crawling through pi and forgetting the previous digits to get to your digit? Clever.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/MiffedMouse" target="_blank">MiffedMouse</a>
			<div class="markdown"><p>It's crazier than that. It turns out there is a sum of ratios of polynomials that gives the nth digit. The sum is technically infinite, but because you know the answer is an integer (and the sum converges nicely) you can stop when you get close enough.</p>
<p>So you can skip directly to the nth digit!</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/mfb-" target="_blank">mfb-</a>
			<div class="markdown"><p>Only works for hexadecimal, unfortunately, and the conversion between that and decimal needs more digits (not all of them, but much more than 1).</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/CountSheep" target="_blank">CountSheep</a>
			<div class="markdown"><p>So it's a series?</p></div>		</li>
					</ul>
		</ul>
		</ul>
	