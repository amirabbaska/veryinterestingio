	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/SunilTanna" target="_blank">SunilTanna</a>
			<div class="markdown"><blockquote>
<p>Since the produced digit and the next state depends on the state alone reaching a previously inhabited state means the sequence of digits start to repeat.</p>
</blockquote>
<p>I think that there's an error in that argument.</p>
<p>Not repeating does not necessarily mean that you need to encode the previous state to get the next state.</p>
<p>Consider for example the continued fraction representation of e.  [2; 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, 1, 1, 10, 1, 1, etc.]. This does not repeat, but it's trivial to &quot;jump ahead&quot; to the million, or trillionith, or googolinth item in the sequence because there is a discernable pattern that can be encoded simply as an algorithm for finding any item in the sequence.</p>
<p>Currently it is true that we do not know of any simple (or complex) pattern to the digits of pi, but we do not know for sure that there is no pattern</p>
<p>(all we actually know for sure, is that if there is a pattern it does not repeat).</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Solesaver" target="_blank">Solesaver</a>
			<div class="markdown"><blockquote>
<p>Not repeating does not necessarily mean that you need to encode the previous state to get the next state.</p>
</blockquote>
<p>Yes, but you need to encode <em>an</em> input state.  In finite memory you can only store a finite number of unique input states so you can only calculate a finite number of unique outputs.  Even with an explicit formula for finding the nth digit of an irrational number (say: the nth digit of a number can be calculated by solving f(n)) how do you solve f(n) for n=10^1000000000000 when you can't store the value of n in memory?</p>
<p>I think the best you could do is translate in input tape of an infinite, non-repeating series into a specific rational number where the some finitely formulaic determination of the nth entry of the series would be the input state to get you the nth digit.  Even then, a computer alone with finite memory isn't going to be able to jump or calculate how to find which entry on the input tape to use.  A machine with infinite memory would have to provide it with the correct input.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/SunilTanna" target="_blank">SunilTanna</a>
			<div class="markdown"><p>Consider the number 0.101001000100001000001...</p>
<p>This is an irrational number.  I can calculate any digit without even considering prior digits.   The n'th digit is 1 if n is triangular, and 0 if not.  I can test if n is triangular by checking if 8n+1 is square.  I do not ned to kniw anything about prior digits.</p>
<p>Yes I might need memory to store n, but I think that was assumed in the question.   </p>
<p>In my examole, you need 4 bits more than the number reqd to store n to store 8n+1</p>
<p>I think that is the spirit of the question. </p>
<p>More to follow.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/WikiWantsYourPics" target="_blank">WikiWantsYourPics</a>
			<div class="markdown"><p>If there's an algorithm that doesn't need to see the whole of n at once, and can work piecewise, and if you don't count the input tape (containing n) as part of the memory, you can process arbitrarily large n as input.</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/F0sh" target="_blank">F0sh</a>
			<div class="markdown"><p>Since the problem was not stated formally you could ask whether there is any Turing machine which, when presented with the input <em>n</em> on one tape, produces the desired output while only writing to a second, finite tape.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/CynicalHarry" target="_blank">CynicalHarry</a>
			<div class="markdown"><p>I thought about that too (theres another answer which debated a similar issue) and I think this depends on the irrational number itself. If the pattern of the irrational number is sufficiently simple then yes, you can, but I'm not sure this true for all irrational numbers.</p>
<p>To answer this question we would need a measure for the complexity of the number pattern itself I think.</p>
<p>EDIT: That's why i generally refer to a state machine rather than a turing machine and talk about the size of the state because even though a turing machine can also be seen as a state machine its state comprises of both the current inhabited state as well as the state of all tapes combined. Otherwise I could solve the problem by proposing a turing machine with an infinite number of states and no extra tape usage at all which <em>would</em> be able to compute the digits.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/F0sh" target="_blank">F0sh</a>
			<div class="markdown"><p>A Turing machine by definition has finitely many states. If you are thinking of simply a 'state machine' then the Turing machine is not a <em>finite state machine</em> which is something else - and indeed could not possess an unbounded tape which would allow infinitely many 'states'.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/anotherdonald" target="_blank">anotherdonald</a>
			<div class="markdown"><p>That's exactly the same problem. You can replace a piece of finite tape by multiplying the internal state. To get out of the limitations of a finite automaton, you need an unbounded tape.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/CynicalHarry" target="_blank">CynicalHarry</a>
			<div class="markdown"><p>I actually have to come back again, because this question has been raised multiple times and I might have had a epiphany.</p>
<p>Even if we disregard the memory the input uses (which is basically what you suggest) and we suppose a simple pattern, we still need unbounded memory. Consider the infinite sequence 1, 2, 1, 3, 1, 4, ... We can calculate the digit at the nth position easily by returning 1 for odd and n/2 for even.</p>
<p>The problem is that n/2 is then unbounded too, if n is. And I think this might be a general property. If we have an infinite, non repeating sequence or an irrational number the n'th position will depend on some measure derived from <em>n</em>. The measure must consider the entirety of <em>n</em> because the number is irrational and therefore distinct indices must have distinct measures or we would be repeating (this collides with the example above, because there it is a sequence, sorry bad example). Since the measure is derived from the input it too is unbounded. Either in his small, or how large it is.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/F0sh" target="_blank">F0sh</a>
			<div class="markdown"><p>Your infinite sequence doesn't make a real number because real numbers (in base 10) only have digits from 0 to 9.</p>
<p>But you consider the following irrational number: 0.1101000100000001... The <em>n</em>th digit is computable as follows:
If <em>n</em> is a power of 2, return 1, otherwise return 0. Whether <em>n</em> is a power of 2 is computable by a finite state machine.</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/morgan423" target="_blank">morgan423</a>
			<div class="markdown"><p>I know it was probably just your phone auto-correcting you, but <em>Digits of Pie</em> would be an outstanding band name.</p></div>		</li>
					</ul>
	