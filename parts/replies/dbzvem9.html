	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/PackOfVelociraptors" target="_blank">PackOfVelociraptors</a>
			<div class="markdown"><p>What I am trying to figure out, it seems to me like this can't possibly work if  collisions are impossible, (since a 1 to 1 function should always be able to be reversed). It seems to me that the less collisions you have, the closer it is to a 1-1, therefore it should be easier go backward and get the original. (Or more likely at least.)</p>
<p>Why can't we create a reverse function that finds <em>a</em> solution? It shouldn't matter if it's right or not. For your example, I could just generate a random few digits, put them in front of 936, and take the square root. That should give access, right?</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/svartkonst" target="_blank">svartkonst</a>
			<div class="markdown"><p>You don't have any data to work backwards with. You can use collisions, and sometimes other clues, to try and find patterns, but you can't reverse-engineer it. </p>
<p>Just like you can't get 3456 from 936, you can't get &quot;hello world&quot; from a948904f2f0f479b8f8197694b30184b0d2ed1c1cd2a1ec0fb85d299a192a447. The initial information has been lost.</p>
<p>and, yeah, you can brute-force your way through it - In this case fairly easy. But then again, the algorithm for my hash was a bit more simple then </p>
<p>EDIT: Might have misspoken a bit. The example algorithm was more to give an example of how we can create a destructive algorithm. </p>
<p>As for collisions, the lower the rate of collisions is, the more secure it is. If the rate of collisions is 50%, you'll only need to guess 2 passwords. If it is 1% you'll need to get 100 passwords correct etc. </p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/PackOfVelociraptors" target="_blank">PackOfVelociraptors</a>
			<div class="markdown"><p>My question was more based on if the person trying to reverse it knows exactly the algorithm used to hash it, like if it's md5 or something open source. If I know the algorithm, shouldn't I be able to get from 3456 to 936, and from 936 back to a different number that that also works out to be 936? </p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/snoopy369" target="_blank">snoopy369</a>
			<div class="markdown"><p>This is one reason to have a salt. Something that will make sure the hashed value is different for each use.  That way even if you do come up with a reversing function and use it, it only gives you access to this one place - odds are you didn't have the right exact password so you won't be able to use the same result anywhere else. </p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/rooxo" target="_blank">rooxo</a>
			<div class="markdown"><p>Even if it is a 1-1 map and thererore a reverse function exists, that doesn't mean the reverse function is easy to calculate. Just take the f(x)=x^2 for positive x as an example. Calculating f(x) is easy but finding the square root(the inverse) takes a lot more compiting power, especially for big numbers. Now that's just a simple function, you can construct more coplicated ones computers nowadays can't crack</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/geekrohan" target="_blank">geekrohan</a>
			<div class="markdown"><p>What happens when 936 output is generated by some other input ?</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/svartkonst" target="_blank">svartkonst</a>
			<div class="markdown"><p>I'll elaborate a bit on what I and u/UnsubstantiatedClaim wrote. </p>
<p>So, the way this works when you log onto an application is that it takes the password you submitted, runs it through the hashing algorithm and then compares the result with the hash stored in a database. So you might have a database table that looks like this: </p>
<pre><code>+------------+---------------+
| USER       | PASSWORD_HASH |
+------------+---------------+
| Bob        | 756           |
+------------+---------------+
| geekrohan  | 936           |
+------------+---------------+</code></pre>
<p>So, when you log in, you submit a password to the application, the application runs it through the algorithm and gets a result, then compares that to the hash stored with your username. </p>
<p>So as you can see, the system doesn't care about your actual password, 3456, it only cares about the resulting hash. </p>
<p>So, along comes a third user, <code>Alice</code>. She registers for the application using a suitable username and password, say <code>alice</code> and <code>9936</code>, but when she logs onto the application she misspells her username and accidentally enters <code>geekrohan</code> instead of <code>alice</code> ... and gains access to your account, since the hashing algortihm generates 936 for her pin code as well, despite the two of you having separate passwords. </p>
<p>This is a collision, and can be used to gain unauthorized access, and might be a clue for anyone looking to crack the algorithm. </p>
<p>In our case, the collission occured because we truncated the result of our hashing algorithm to a 3-digit number, with 10 possible values for each value, or 10^3 possible hashes. For SHA-265 this number is 2^256. </p>
<p>There are, and have been, systems that are/were vulnerable due to another variant. These systems didn't use hashing at all, but stored passwords in plaintext. On top of that, they truncated the passwords to, say, 8 characters without notifying users. So you and I might register for the site, you with <code>password1</code> and I with <code>password2</code>. the system accepts our passwords, but since it silently slices off the final digit, we really have the same password.</p>
<p>A bit long-winded, perhaps, but hopefully I got some points across. </p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/UnsubstantiatedClaim" target="_blank">UnsubstantiatedClaim</a>
			<div class="markdown"><p>Then you get a hash collision and the incorrect password can be used to gain access. Good hashing algorithms minimize the number of collisions (as /u/svartkonst said this example is simple) so the likelihood of two different passwords having the same hash is low.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Tyra3l" target="_blank">Tyra3l</a>
			<div class="markdown"><p>which means that when you brute forced/rainbow table looked up a value with the same hash it is unlikely that you found a collision but recovered the original value.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ResetterofPasswords" target="_blank">ResetterofPasswords</a>
			<div class="markdown"><p>Access is granted </p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/GregLittlefield" target="_blank">GregLittlefield</a>
			<div class="markdown"><p>That was a very clear answer; thanks.</p></div>		</li>
					</ul>
	