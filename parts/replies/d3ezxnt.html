	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/YoungsterGlenn" target="_blank">YoungsterGlenn</a>
			<div class="markdown"><p>I'm even later, but I completely agree that most answers were lacking, so I've expanded on your answer because I think it's the best one.</p>
<p>This is a bit of an oversimplification, but how fast you can solve a Rubik's cube is basically limited by two factors:</p>
<ol>
<li>The total number of turns of the cube faces you need to take the cube from a scrambled state to its solved state.</li>
<li>How many timer per second you can turn the cube faces.</li>
</ol>
<p>This means that all improvements to a person's cubing speed have to improve at least one of these two aspects. If you don't know how to solve a Rubik's cube at all, it's likely that it would take you hundreds of thousands of turns of the cube faces to figure out a solution of your own. Coming up with an original solution strategy is entirely doable, but would take a lot of time, and would be likely to generate a really inefficient solution method. So instead, most people just find an existing solution method and learn it.</p>
<p>A solution method for the Rubik's cube is typically a list of simplified cube states along with various strategies for taking the cube from one state to the next. More concretely, here's what a solution method could look like (where some pieces are greyed out because it doesn't matter what they are):</p>
<ol>
<li>Take the scrambled cube and form a solved cross on the bottom face, like <a href="https://i.imgur.com/LGPx5W4.png" target="_blank"><strong>this</strong></a> (backside: <a href="https://i.imgur.com/3r6nIgy.png" target="_blank"><strong>this</strong></a>). Note how the colours on the sides of the cube match, unlike in <a href="https://i.imgur.com/fmrCV0L.png" target="_blank"><strong>this</strong></a> picture. If the edge and centre colours on the sides don't match, the cross is not very useful, because of how the cube is constructed. As you can see in <a href="https://www.youtube.com/watch?v=bgcScY7CiMs&amp;t=30s" target="_blank"><strong>this video</strong></a>, on a standard cube, the blue and green centres will always be on opposite sides, as will the orange/red and yellow/white centres. And even further, if you have the white centre on the bottom and the blue centre facing you, the red centre will always be on the right face (which means that orange is on the left face, yellow is on the top face, and green on the back face). These facts combined mean that a cross like <a href="https://i.imgur.com/fmrCV0L.png" target="_blank"><strong>this one</strong></a> isn't actually very useful for a solve, since you can't swap the place of the blue and red centres. This step is simple enough to be done intuitively.</li>
<li>Use the top face of the cube to pair up one corner piece with one edge piece so that a matching pair if formed, and make sure that the corner piece but not the edge piece has one sticker matching the colour of the cross, like <a href="https://i.imgur.com/zjOkGPN.png" target="_blank"><strong>this</strong></a>. Then, insert the corner-edge pair into its corresponding slot among the bottom two layers, like <a href="https://i.imgur.com/FTg4VTP.png" target="_blank"><strong>this</strong></a>. Repeat this procedure (form pair and insert) three more times to finish the bottom two layers of the cube. It will look like <a href="https://i.imgur.com/3Mjwn93.png" target="_blank"><strong>this</strong></a> (backside: <a href="https://i.imgur.com/KWVmVit.png" target="_blank"><strong>this</strong></a>). This step can be accomplished intuitively. It's also possible to learn <a href="http://www.kungfoomanchu.com/guides/andy-klise-3x3x3-speedcubing-guide-v4.pdf" target="_blank"><strong>42 algorithms</strong></a> (only the first page) and then for each slot identify and execute one of these algorithms to form a pair and insert it.</li>
<li>Make all of the top face one colour. At this point, you'll have something like <a href="https://i.imgur.com/29MUAkw.png" target="_blank"><strong>this</strong></a> (backside: <a href="https://i.imgur.com/G69EaZC.png" target="_blank"><strong>this</strong></a>) and you want to turn it into something like <a href="https://i.imgur.com/ftsGXiq.png" target="_blank"><strong>this</strong></a> (backside: <a href="http://i.imgur.com/fyNovJY.png" target="_blank"><strong>this</strong></a>). You don't care at all what the edge colours are; all you want to do is make sure that the top has a single colour. This step is not feasible to do intuitively, instead, you memorise <a href="http://www.kungfoomanchu.com/guides/andy-klise-3x3x3-oll-v3.pdf" target="_blank"><strong>57 algorithms</strong></a> and just choose the correct one.</li>
<li>Complete the solve. Again, this is not feasible to do intuitively, so you memorise <a href="http://www.kungfoomanchu.com/guides/andy-klise-3x3x3-speedcubing-guide-v4.pdf" target="_blank"><strong>21 algorithms</strong></a> (the right half of the second page).</li>
</ol>
<p>The method I've outlined above is called CFOP for <strong>C</strong>ross, <strong>F</strong>2L (First 2 Layers), <strong>O</strong>LL (Orient Last Layer), and <strong>P</strong>LL (Permute Last Layer), or sometimes the Fridrich method (after Jessica Fridrich who came up with some popular algorithms for the OLL and PLL). It's by no means a beginner's method, but it is the one most people who get really low times use. You can make a beginner's method out of CFOP by dividing each of F2L, OLL and PLL into several substeps which require only one or two algorithms to solve per step (<a href="https://www.youtube.com/watch?v=609nhVzg-5Q" target="_blank"><strong>video tutorial</strong></a>). This way you have to memorise only about ten short algorithms. You can then slowly work your way up to the full CFOP method by learning to do the OLL and PLL in two steps each (<a href="https://www.youtube.com/watch?v=DTYvklyOpVM" target="_blank"><strong>this</strong></a> and <a href="https://www.youtube.com/watch?v=S61q3FYVFis" target="_blank"><strong>this</strong></a>) before finally tackling the full PLL and OLL.</p>
<p>So how does a method like CFOP allow for such quick solves? It deals with the first condition from above fairly well, with average solves around 55 moves (<a href="https://www.speedsolving.com/wiki/index.php/CFOP" target="_blank">source</a>). Still, other methods like <a href="https://www.speedsolving.com/wiki/index.php/Petrus" target="_blank">Petrus</a> (~50), <a href="https://www.speedsolving.com/wiki/index.php/Roux" target="_blank">Roux</a> (~48) and <a href="https://www.speedsolving.com/wiki/index.php/Heise_Method" target="_blank">Heise</a> (~40) have even lower move counts. The reason CFOP beats these methods in real time speed is most likely because once you form the cross in the CFOP method, you never have to look at the bottom layer again, and if you pay attention while making the cross you actually typically won't have to look at the backside of the cube again during the solve (you keep in memory what pieces are where). This means that as soon as you're done with the cross, you don't have to rotate the cube much, and all that remains is pattern recognition and execution of memorised algorithms. If you do this well, you can basically turn the cube faces non-stop for the entirety of your solve. Most other methods require either more planning and thinking during the solve or simply more looking at different sides of the cube to see which pieces are where. This ends up costing more time than is saved by the smaller move count. Basically, CFOP is not the best at my first condition (low move count) but truly excels at my second one (many moves per second) and ends up being the fastest feasible method for most people.</p>
<p>Another aspect that I haven't discussed so far is the actual speed with which the cuber can turn a layer. Speedcubers typically don't use actual Rubik's cubes but off-brand cubes that turn faster, lock up less, and fall apart less often. Speedcubes have become better and better over time, which also contributes to lower times. (High move count/low brain effort methods like CFOP benefit more from this since they had more moves to begin with. If everybody had to use official Rubik's cubes maybe we'd see methods like Petrus or Heise doing better.) On top of that, most speedcubers learn efficient finger movements to turn layers quickly (usually called finger tricks) and many also try several of the available algorithms for any given case until they find ones they prefer (usually ones that eliminate left hand usage or turns of the bottom or back layer of the cube).</p>
<p>Now, if you learn all of the above you probably land at solves averaging around 30 seconds long. At this point it's all about practice. You will obviously want faster finger speed and (if you don't already have one) a faster cube, but most importantly you'll have to lower your decision times. The by far biggest time sink for most people is that they don't recognise the different cases as quick as they could, or that they need time to think of which algorithm to use once they do. So not only would you want to memorise 42+57+21=120 algorithms for the full CFOP, you'd need to memorise the corresponding patterns these cases lead to when looking at the cube (and there are more than 126 of these because you can for instance see each PLL case from four different angles, and if you want to be fast you want to recognise the case without rotating the cube). Finally, I think some of the absolutely fastest speedcubers have memorised a few extra cases and corresponding algorithms on top of the basic CFOP ones. I believe Feliks Zemdegs (who has the lowest average time) has memorised algorithms for about a hundred of the 493 <a href="https://www.speedsolving.com/wiki/index.php/ZBLL" target="_blank">ZBLL</a> cases, which is a set of algorithms for solving the entire last layer in one step assuming the edges of the top layer were oriented correctly after finishing the first two layers (which will only happen occasionally in the first place). He also completes the first pair of the F2L phase while making the cross when it's particularly easy to do so. (You get 15 seconds of inspection time before starting your solve, which is basically enough to plan out the entirety of the cross and in simple cases also the first F2L pair.)</p>
<p>As a final note, it's entirely possible to solve a Rubik's cube intuitively. However, deriving your own algorithms for the latter stages of the CFOP method is about as hard as coming up with an entire solution method completely from scratch, so it's not really something I would recommend. If you want an intuitive method, the Heise method is pretty good, but it's not for the faint-hearted and significantly harder to learn than CFOP. I also think it's possible for anybody with a knack for mathematics or otherwise figuring out patterns to come up with an ugly but functional solution method given a few weeks of experimentation.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/bgnwpm8" target="_blank">bgnwpm8</a>
			<div class="markdown"><p>That's a really long explanation...</p>
<p>But the most correct one here.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Moogle02" target="_blank">Moogle02</a>
			<div class="markdown"><p>aren't there only 17 PLLs?</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/YoungsterGlenn" target="_blank">YoungsterGlenn</a>
			<div class="markdown"><p>There are 21 (22 if you count solved), I don't know what I was thinking. It's fixed now.</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ggadget6" target="_blank">ggadget6</a>
			<div class="markdown"><p>TIL Redkb is on Reddit.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/AnimeAndComputers" target="_blank">AnimeAndComputers</a>
			<div class="markdown"><p>I'm extremely late but I'll comment just for RedKB</p></div>		</li>
					</ul>
	