	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/AberrantRambler" target="_blank">AberrantRambler</a>
			<div class="markdown"><p>It also depends on exactly what they mean by &quot;storing&quot; as to actually store that file there will be more (file name and dates, other meta data relating to the file and data relating to actually storing the bits on some medium)</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/djzenmastak" target="_blank">djzenmastak</a>
			<div class="markdown"><p>moreover, the format of the storage makes a big difference, especially for very small files.  if you're using the typical 4KB cluster NTFS format, a 100 word ASCII file will be...well, a minimum of 4KB.</p>
<p>edit:  unless the file is around 512 bytes or smaller, then it may be saved to the MFT.</p>
<p><a href="https://www.reddit.com/r/askscience/comments/7dknhg/if_every_digital_thing_is_a_bunch_of_1s_and_0s/dpyop8o/" target="_blank">https://www.reddit.com/r/askscience/comments/7dknhg/if_every_digital_thing_is_a_bunch_of_1s_and_0s/dpyop8o/</a></p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/modulus801" target="_blank">modulus801</a>
			<div class="markdown"><p>Actually, small files and directories can be stored within the MFT in NTFS.</p>
<p><a href="http://www.ntfs.com/ntfs-mft.htm" target="_blank">Source</a></p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/wfaulk" target="_blank">wfaulk</a>
			<div class="markdown"><p>Well, that's how much disk space is used to hold the file; that doesn't mean the data magically becomes that large.  It's like if you had some sort of filing cabinet where each document had to be put in its own rigid box (or series of boxes), all of which are the same size. If you have a one page memo, and it has to exist in its own box, that doesn't mean that the memo became the same length as that 50-page report in the next box.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/SirNanigans" target="_blank">SirNanigans</a>
			<div class="markdown"><p>The file wouldn't <em>require</em> 4KB, though. The file system is simply incapable of assigning another file to part of that 4KB &quot;block&quot; of the storage disk.</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/angus725" target="_blank">angus725</a>
			<div class="markdown"><p>It is possible to program with 1s and 0s. Unfortunately, I've done it before.  </p>
<p>Typically, you search up the binary representation of the assembly language, and basically translate the program in assembly language to binary (in hexadecimal). It takes abolutely forever to do, and it's extremely easy to make mistakes.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/knipil" target="_blank">knipil</a>
			<div class="markdown"><p>Yep. Old computers had <a href="https://en.m.wikipedia.org/wiki/Front_panel" target="_blank">Front Panels</a>. They consisted of a set of switches for selecting the memory address, and a set of switches for specifying the value to write to that address. Once you’d finish keying in the value, you’d press a button to perform the write. The salient point here is that the on/off states of a mechanical switch corresponded directly to a 0/1 in memory. No computer has - to my knowledge - ever had a modern style keyboard where a programmer would enter 0 or 1, at least not for anything else than novelty. It was done routinely on front panels on early computers, though.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/angus725" target="_blank">angus725</a>
			<div class="markdown"><p>Programming stuff in Hexcidecimal is basically programming in binary. Had to do a bit for a computer security course.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/turunambartanen" target="_blank">turunambartanen</a>
			<div class="markdown"><blockquote>
<p>It takes abolutely forever to do, and it's extremely easy to make mistakes.</p>
</blockquote>
<p>Or - thanks to the geniuses and hard working normal people before us - you could write a high level program to convert assembly to binary.</p>
<p>*nowadays. Some decades ago you actually had to do it by hand.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/angus725" target="_blank">angus725</a>
			<div class="markdown"><p>Certain exploits still need hand written machine code to work. I'm not sure if there are any optimizations that are possible at that level, so it could be purely for &quot;illegitimate&quot; uses.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/oatscoop" target="_blank">oatscoop</a>
			<div class="markdown"><p>I had a cheat sheet for the Z80 TI-83 calculator with the hex representations of instructions, common BCALLs, etc</p>
<p>I was a massive nerd though.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/angus725" target="_blank">angus725</a>
			<div class="markdown"><p>neeeeeerd  </p>
<p>If that low level of code interests you though, I believe there's still a few companies hiring for assembly level optimization...</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/darcys_beard" target="_blank">darcys_beard</a>
			<div class="markdown"><blockquote>
<p>And in theory you could program directly with ones and zeros, but you would have to literally be a god to do so, since the stream would be meaningless for mere mortals.</p>
</blockquote>
<p>The guy who made Rollercoaster Tycoon wrote it in assembly. To me, that is insane. </p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/enjineer30302" target="_blank">enjineer30302</a>
			<div class="markdown"><p>Lots of old games were assembly-based. Take any old console game from the 16-bit era - they all were written in assembly for the system CPU (ex: SNES was 65c816 assembly, NES was 6502 assembly, and so on and so forth). I can't even imagine doing what someone like <a href="https://www.youtube.com/channel/UCuvSqzfO_LV_QzHdmEj84SQ" target="_blank">Kaze Emanuar does in assembly to hack Super Mario 64</a> and add things like a working portal gun to the game. </p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/samtresler" target="_blank">samtresler</a>
			<div class="markdown"><p>I always liked NES Dragon Warrior 4. They used every bit on the cartridge. Many emulators can't run the rom because they started counting at 1 not 0, which wasn't an issue for any other NES game.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/swordgeek" target="_blank">swordgeek</a>
			<div class="markdown"><p>In my youth, I did a lot of 6502 assembly programming. It was painful, but doable. Really, that's just how we did things back then.</p>
<p>These days, no thanks.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/TheRealChrisIrvine" target="_blank">TheRealChrisIrvine</a>
			<div class="markdown"><p>In the early 2000s I built and programmed a computer with a 6502 chip. I am so thankful that I don't have to use assembly on a regular basis. </p></div>		</li>
					</ul>
		</ul>
		</ul>
	