	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Saith_Cassus" target="_blank">Saith_Cassus</a>
			<div class="markdown"><p>Thank you. Everyone in this thread is tossing around so much lingo I'm unfamiliar with. This agreed with how I thought it worked from context clues. </p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/_mainus" target="_blank">_mainus</a>
			<div class="markdown"><p>A computer program is a list of instructions to the processor, each one executes sequentially, one after the other, with the exception of &quot;branches&quot; which cause it to jump to other parts of the program. Debugging involves stepping through each instruction one at a time, slow enough so a human can watch what is happening. If you pay close enough attention you can find where the DRM check occurs, you can then modify the program to skip it.</p>
<p>It's complicated because modern programs are hundreds of millions of instructions long, and cannot be read the same way they are written... when you write in a &quot;high level language&quot; it's a lot more human-readable, but when debugging someone else's program it is no longer in that high level language but instead in machine code, which is far FAR less human-readable. In the high level language you have names that identify what things are and what they do, you have very visible looping and branching constructs that you can see just from the syntax of the language, in machine code you don't have any of this, just a string of a billion hexadecimal characters with no structure.</p>
<hr />
<p>Funny story, the first day of my embedded systems class in college the professor had us step through a program in the manner I just described and write down changes made to memory at each step... the program was a complex infinite loop, it never ended... but he did it in a way that wasn't obvious just by watching the memory contents as he asked us to do. The class was almost over and the students were frantically writing and stepping and writing and stepping... worrying they were going to run out of time. I realized what he had done about 5 minutes from the end of class and took my paper up to him and whispered &quot;That's cruel&quot; and walked out.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ElBroet" target="_blank">ElBroet</a>
			<div class="markdown"><p>&quot;That's cruel&quot; he says with an inner sense of accomplishment and pride for getting it anyways, along with an added sense of comradery since now you and the teacher (and anyone else who figured it out) form a group of those &quot;in&quot; on the trick.  Feels</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Selrisitai" target="_blank">Selrisitai</a>
			<div class="markdown"><p>The way you describe it, I can easily see how hackers could do this for the thrill of the hunt, a challenge on par with a difficult Mario level.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/crusaderblings2" target="_blank">crusaderblings2</a>
			<div class="markdown"><p>Funny you mention that. Look up the fastest Super Mario speedrun. If you do everything in a very very very mathematically precise way, you can get to the end of the game in a couple seconds.</p>
<p>The guy discovered this by seeing what variables need to be set in memory for the game to trigger end credits. Doing things in a specific order changes the memory in a way that puts that flag in the same memory spot as if you beat Bowser. Theres a video on Youtube explaining it and visualizing it.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/LonePaladin" target="_blank">LonePaladin</a>
			<div class="markdown"><p>There's a subset of speedruns called &quot;tool-assisted&quot;. A tool-assisted speedrun (TAS) uses software that allows you to pause a game at any time, as well as rewind, speed up, or slow down — you can literally slow a game down to a single frame at a time. Someone making a TAS can carefully plan every single input on a game, then use frame-by-frame to execute those moves with perfect precision.</p>
<p>They can also use the emulator to track numbers the game uses 'under the hood', so they can know precisely when something happens even if it can't be seen. When it's all put together and run at normal speed, a TAS plays as if someone with perfect reflexes (and the ability to see the future) is playing.</p>
<p>TAS creators like to do things like abuse glitches, or avoid entire sections of a game, in order to get done faster. With some games, they can even put in a string of inputs during an opening screen to manipulate a random generator.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Selrisitai" target="_blank">Selrisitai</a>
			<div class="markdown"><p>I can't find that one.</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/_PM_ME_PANGOLINS_" target="_blank">_PM_ME_PANGOLINS_</a>
			<div class="markdown"><p>You cannot get “step” rate from the clock speed. Most steps take longer than one clock cycle, and at the same time there are multiple steps happening at once.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/elementalcode" target="_blank">elementalcode</a>
			<div class="markdown"><p>Ok, things will get a bit techier:</p>
<p>When programming a &quot;step&quot;, an instruction can take many clock cycles.</p>
<p>When reverse engineering you see Assembler code. Each line of assembler code is an instruction to the processor. While there are multi-core processors and technically you could be running more than one instruction on a single processor that is rarely the case in games.</p>
<p>Also, some of the instructions that the processor will get will be from your drivers, operative system and other apps running. So not all the cycles will be for your game.</p>
<p>I said &quot;approx&quot; because of all of this.</p>
<p>Edit: PS: Using a really big number adds to the wow factor :D</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/yourio5432" target="_blank">yourio5432</a>
			<div class="markdown"><p>I believe /u/_PM_ME<em>PANGOLINS</em> is talking about instruction pipelining.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/WM46" target="_blank">WM46</a>
			<div class="markdown"><p>And you also need to consider V-blank periods where the processor might idle after drawing the current frame, but that's why this is a good ELI5.</p></div>		</li>
					</ul>
		</ul>
	