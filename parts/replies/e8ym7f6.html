	<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/chetanraj38" target="_blank">chetanraj38</a>
			<div class="markdown"><p>Amazed by how much work is done within milliseconds</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Dodgeballrocks" target="_blank">Dodgeballrocks</a>
			<div class="markdown"><p>Modern processors reach speeds of over 4GHz, that's processing at 4,000,000,000 times a second. We're way passed milliseconds here. </p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/alblks" target="_blank">alblks</a>
			<div class="markdown"><p>Well, it's more complicated, as most of operations require more than one &quot;processor tick&quot;, and there are various issues with the synchronisation of the work of different devices, but your point still stands.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/nozyparker6" target="_blank">nozyparker6</a>
			<div class="markdown"><p>How does this compare to the human brain, is it faster or slower?
edit;
Perhaps that should be a seperate question.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/sniffles_snort" target="_blank">sniffles_snort</a>
			<div class="markdown"><p>Hmmm is Ghz the same as operations per second?</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/HeKis4" target="_blank">HeKis4</a>
			<div class="markdown"><p>I am a sysadmin with a dev education and I still can't fathom how much processing power a game needs, yet it does it once every 15 milliseconds. That's actually insane.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/SomeGuyInNewZealand" target="_blank">SomeGuyInNewZealand</a>
			<div class="markdown"><p>Now think about how something like gta5 keeps lots of cores busy...</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Superbead" target="_blank">Superbead</a>
			<div class="markdown"><p>I've used 8-bit PIC microcontrollers in some home projects and, as a masochist, I program them in assembly language. You find these today in kids' toys, basic kitchen appliances, that kind of thing. The last one I used ran at 4MHz â€” the kind of clock speed you'd find in home computers and arcade machines from the '80s.</p>
<p>Each assembly instruction takes four clock cycles to execute, so running at 4MHz, the processor takes one microsecond to execute each instruction. This means you can more or less count the instructions in your code and easily work out how long it'll take to run.</p>
<p>It's weird looking at pages of code and knowing it can all execute in less than a millisecond on a mere 4MHz chip!</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Varonth" target="_blank">Varonth</a>
			<div class="markdown"><p>Well a slight correction. Machine code can be understand by humans, which is a given considering that humans invented it in the first place.</p>
<p>Sure, writing direct 0 and 1 is unfeasible if only for the sheer amount of typing involved, but there is basic assembly. Without the usage of macros and other techniques to make even assembly more friendly to the programmer, assembly is essentially writing direct machine code.</p>
<p>And assembly is still written in certain industries to this very day.</p>
<p>Programming in high level languages is done because it removes so much work from the programmer. Just as an example:</p>
<p>The x86 function for ADD is split into <a href="https://c9x.me/x86/html/file_module_x86_id_5.html" target="_blank">14 different types</a>.</p>
<p>While adding 2 things in a high level language is as simple as writing 1+2, in assembly and therefor in machinecode you have to load the numbers from the correct memory location into the correct register for your chosen ADD command before you can actually use the ADD.</p>
<p>Doing this isn't impossible. In fact, <a href="http://www.chrissawyergames.com/faq3.htm" target="_blank">Chris Sawyer wrote almost all of the original Roller Coaster Tycoon in x86 assembly</a>.</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/FireIriss" target="_blank">FireIriss</a>
			<div class="markdown"><p>Thanks for pointing this out. I was slightly irritated considering I learned and used both Assembler (x86) and machine code this spring. </p>
<p>In some ways it is honestly easier to understand, once you get a hang of the logic behind. But much more labour intensive of course.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Flopsikin" target="_blank">Flopsikin</a>
			<div class="markdown"><p>Isnt high frequency trading still done in assembler code by highly specialized experts because it has less performance overhead and therefore less latency?</p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/saevarb" target="_blank">saevarb</a>
			<div class="markdown"><p>Nope. Or rather, I doubt it, but I don't know it for a fact.</p>
<p>The effort required to write it all in assembly while maintaining quality would be absolutely insane. Safety is probably more important because not trading fast enough means some lost money but a broken program trading the wrong things because of a bug could literally lose billions in seconds.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/mywrkact" target="_blank">mywrkact</a>
			<div class="markdown"><p>Nobody really uses assembler on a large scale basis, but the fastest firms do use FPGAs for some types of data processing.  It's also possible that in the profiling and optimization process, some engineers would write some functions in assembler, but honestly, compilers with optimization are really really good these days so it's less necessary and there are bigger data structure and algorithm issues to work on.</p></div>		</li>
						<li class="reply">
			<a class="author" href="https://www.reddit.com/user/Pitarou" target="_blank">Pitarou</a>
			<div class="markdown"><p>Quite possibly. If you're willing to make that kind of investment, rewriting some of your code in assembly (which is one step above machine code) could give you a few microseconds' advantage.</p>
<p>If that's still not fast enough, switch to FPGAs, which are a kind of reconfigurable general purpose microchip.</p>
<p>If even that's not fast enough, than you need to throw serious money at designing and fabricating custom microchips.</p></div>		</li>
					</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/kimber_kelly" target="_blank">kimber_kelly</a>
			<div class="markdown"><p>Amazing </p></div>		</li>
					<ul class="replies">
		<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ergzay" target="_blank">ergzay</a>
			<div class="markdown"><p>To add on to this, almost everything that's required to be super super fast is often hand-tuned assembly. For example the cryptographic equations that are key to you having an encrypted connection to this website are usually hand written assembly buried under a ton of layers of software. (If using chrome, click the padlock, click the Certificate button, click &gt; Details, and then find the &quot;Signature algorithm&quot; which should say &quot;SHA-256 with RSA Encryption&quot;. The raw mathematics of those two algorithms (SHA-256 hashing and RSA Encryption) are likely written in hand-written assembly))</p></div>		</li>
					</ul>
		</ul>
			<li class="reply">
			<a class="author" href="https://www.reddit.com/user/ReallyHadToFixThat" target="_blank">ReallyHadToFixThat</a>
			<div class="markdown"><blockquote>
<p>Then it gets converted into machine code, literally the ones and zeros of binary. At this point, only the processor understands it.</p>
</blockquote>
<p>I have an uncle that could understand machine code. He worked on machines so old you had to delete the compiler to make room for your program. So you'd start with readable code, but then any debugging or tweaks would be done in the binary. </p></div>		</li>
					</ul>
	