<div class="answers">
	<div class="answer" data-handle="dc2t30l">
		<a class="author" href="https://www.reddit.com/user/throwaway_lmkg" target="_blank">throwaway_lmkg</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>Trust me, if that were the case, we would be hearing about it. </p>
<p>Google's program is not &quot;solving&quot; Go in the strict CS sense. It is not evaluating every possible outcome of every possible board state. It is using heuristics to choose some possible moves to sample, and it is using other heuristics to evaluate the outcomes of those moves rather than calculating all the way to the end of the game. In a certain sense it's an approximation algorithm, but it's not entirely clear to me what it's approximating because its objective is to beat its opponent, not to play a &quot;perfect&quot; game.</p>
<p>Technically, P vs NP doesn't come into play at all because the board size is constant and therefore the set of possible moves is bounded by a constant. We can't say that the algorithm is running in polynomial time unless we answer &quot;polynomial of what?&quot; The neural nets are running in constant-bounded time on problems of constant-bounded size.</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
	<a class="less-answers upper" href="javascript:void(0)">less answers...</a>
	<div class="answer" data-handle="dc2t4j0">
		<a class="author" href="https://www.reddit.com/user/pku31" target="_blank">pku31</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>It's not unbeatable, just better than humans. It's software doesn't try &quot;solving&quot; Go (which is EXPTIME hard, not just NP hard). Instead, it has a system that evaluates how good a situation for it is using various heuristics, and then tries to read ahead to get to these situations - much like how humans approach the game.</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
	<div class="answer" data-handle="dc2tdxm">
		<a class="author" href="https://www.reddit.com/user/obnubilation" target="_blank">obnubilation</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>No. Go is (probably) not in NP. It's EXPTIME-complete and so it's provably not solvable in polynomial time.</p>
<p>But no one is suggesting that AlphaGo plays perfectly. It just seems to play better than the best humans. Humans can't solve NP-complete problems efficiently either.</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
	<div class="answer" data-handle="dc302zz">
		<a class="author" href="https://www.reddit.com/user/zapbark" target="_blank">zapbark</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>The core thing the Google Go team tried to do, was to make an algorithm that could look at a go board state (e.g. all the pieces, how many captured, whose turn) and &quot;score&quot; that, to tell who is winning.</p>
<p>Once you have that, you can evaluate which moves are better (since they change the board state).</p>
<p>Step 1: It watched a whole lot of professional go games</p>
<p>Step 2: It looked at who won those games and used that as a mechanism for going back over all the moves of the game to &quot;score the board&quot; so that the AI could tell which board state was &quot;better&quot;.</p>
<p>Step 3: It then played a lot of matches against itself, with some of the &quot;players&quot; using different &quot;board state&quot; algorithms.</p>
<p>Step 4: It then used the results of those games to better predict board state.  Rinse and repeat back to Step 3.</p>
<p>Now, I have cut out some steps for brevity.</p>
<p>But it is an incremental algorithm improvement, often using highly parallelized random tree-walking to test out <em>a lot</em> of states, but no where close to all of them.</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
	<div class="answer" data-handle="dc2tj63">
		<a class="author" href="https://www.reddit.com/user/Nyrin" target="_blank">Nyrin</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>Like any other machine learning problem, it's a system trained against and optimized for a very specific problem space. It's not perfect, can always be improved upon with more data and better training, and is in no way generalizable to every problem.</p>
<p>If you're interested in learning more, read up on concepts of hidden Markov models and deep neutral networks; the whole area initially appears to be black magic, but quickly reveals itself to be a great application of mathematical elegance.</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
</div>