<div class="answers">
	<div class="answer" data-handle="d7qhwhu">
		<a class="author" href="https://www.reddit.com/user/remy_porter" target="_blank">remy_porter</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>Lots of answers in the thread, but I want to drop one as well.</p>
<p>Programming is <em>hard</em>, and it used to be much harder. Once upon a time, you had to write all of your programs in a machine-specific variant of Assembly language. The code I wrote for a PDP-11 wouldn't run on a different type of computer. Worse, Assembly languages generally required a very thorough knowledge of the specific CPU architecture.</p>
<p>That's inconvenient. There were a number of &quot;high level languages&quot; out there- COBOL, Fortran, LISP, and while they might be fine for day to day work, they were terrible choices for what we call &quot;systems programming&quot;- doing something like writing an operating system, or interfacing directly with a piece of hardware. But they were <em>portable</em> (a COBOL program could run on any computer that had a COBOL compiler), and they were much easier to program.</p>
<p>What was needed was a high level language that could easily be translated into Assembly (and machine code), but wasn't as abstract or distant from the hardware as languages like COBOL. Something that was basically &quot;user friendly Assembly&quot;, that had the benefits of portability. That language was C.</p>
<p>C was used to write Unix, and quickly became on of the dominant languages for writing software. It was fast, it was powerful, and it was <em>everywhere</em>. Its syntax became what programming is. Even languages that have no relationship to C at all, like JavaScript, use a similar syntax. So when programming philosophies began to change, and ideas like &quot;Object-Oriented Programming&quot; rose to ascendance, people took the approach of grafting these new concepts onto a C-like syntax.</p>
<p>Enter C++ and Objective-C. Both of these languages introduce a new high-level abstraction: the <em>object</em>. They encourage you to write your programs as models of real-world systems. If you're managing a bank, you'll have an actual <em>object</em> in code called &quot;BankAccount&quot;, and it has both behavior (things it can do) and attributes (data).</p>
<p>That's the key difference between these languages and plain-old C (although how they handle memory is also an important difference). As far as the difference between C++ and Obj-C, that difference is how they <em>designed</em> their object-oriented concepts. Obj-C lifted all of its features from a different language called Smalltalk. Essentially, Obj-C is what happens when Smalltalk and C have a baby (and, while there are some interesting features in it, let's be honest: it's an <em>ugly</em> baby). The goal of Obj-C was to retain all the best parts of both, and it partially succeeded.</p>
<p>C++, on the other hand, took an approach to managing objects that was closer to C-style syntax. Of the two, C++ became the dominant choice- it had speed <em>similar</em> to C, but objects were a useful abstraction.</p>
<p>Phew. Okay, finally, that brings us to C#, and to understand C#, we have to understand Java. Back in the 1990s, we were dealing with portability again. While a C program can be ported between computer architectures more easily than Assembly, it's not <em>instant</em>. You often have to customize the code, and even if you don't, you have to compile that code for each architecture. So the folks behind Java had a bright idea: what if we ran all our programs in a virtual machine- a &quot;in memory&quot; computer that we simulate? The idea was that they could port <em>Java itself</em> to different architectures, and then programmers could write a Java program that would run <em>any place Java worked</em>, without having to ever modify their program or compile it for different architectures. Java lifted most of its syntax from C++ with heavy modifications.</p>
<p>Fast forward to the early 2000s. Microsoft has been releasing its own Galapagos-mutant version of C++ for ages now, and it also has this ugly bastard language called Visual Basic, which is weirdly popular butâ€¦ just terrible. They've been watching what's happening in the Java space, and decide, &quot;Goddamn, I want some of that action.&quot; So using the concepts of Java as a starting point, they create .Net. .Net, like Java, has a concept similar to a virtual machine. C# is a language that lifts features from Java and C++ (and a number of others) and creates code that can run on the .NET Common Language Runtime.</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
	<a class="less-answers upper" href="javascript:void(0)">less answers...</a>
	<div class="answer" data-handle="d7qesg7">
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>Don't be confused by the letter C. Honestly, these languages really have very little in common.</p>
<p>C is quite old. Back when every company that sold computers made them quite differently, the &quot;operating system&quot; was very specific to the computer as well. In the early 1970s, Dennis Ritchie and Ken Thompson worked on what would become the UNIX operating system. UNIX was created for the PDP-11 computer, and in order to make it work on other computers, UNIX had to be portable (modifiable so that it works on other platforms). Dennis Ritchie started out with the programming language BCPL for this task, which already had the purpose of making portable programs. He continued tweaking the compiler and adding features to the language, and eventually ended up inventing C. As UNIX grew popular in academic and business circles, so did C: everything in UNIX was written in C, UNIX came with the source code and a C compiler, and there was an amazingly effective tutorial for C (co-written by Brian Kernighan).</p>
<p>Meanwhile, and also long before C and UNIX, other programming languages were developed with different focuses. One of them was Simula, which was developed in the mid-1960s. This language was mostly made to simulate (hence the name) how groups of 'objects' communicate with each other. Other programming languages built upon these ideas.</p>
<p>Objective C and C++ were created around the same time (in the 1980s), as a way of combining the very well-known programming language C and the very useful style of thinking in 'objects'. While the latter was already possible in C, it wasn't very <em>convenient</em>. </p>
<p>Many other variations on C were created, but very few of them are as well-known as the one you listed. For instance, in the late 1990s, Microsoft had Simple Managed C (SMC), which they used to write most of their &quot;class libraries&quot; (the basic tools they need to make programs). Probably because it had become hard to write software using SMC in a way that makes it easy to maintain, a team within Microsoft decided to create a new language. Eventually, they settled on the name C#.</p>
<hr />
<p>Many of the practical differences between these languages come from their history. C is quite old, and to make sure that all different C compilers understood programs written in &quot;C&quot;, it was standardised early on. The goal of C is to write <em>portable</em> software (and yet, its goal is also to write <em>non-portable</em> software... long story), and even though there are some new versions of this standard, C really sticks to what it originally did. Old code works on new compilers, and to some extent, new code works on old compilers. But because of this, C is very limited in what you can <em>conveniently</em> do with it.</p>
<p>Objective C and C++ are very similar in what convenient extras they offer, but they offer them in a very different way. The main difference is in how you write it down; it's similar to the difference between speaking German and speaking Japanese.</p>
<p>C#, as /u/brendel000 explains, is quite a different beast. Like its predecessor SMC, it is a &quot;managed&quot; programming language: the compiler usually doesn't translate C# into machine code -- the language that your computer's processor understands -- but into bytecode -- a language that a virtual or 'fake' processor understands. A virtual machine &quot;manages&quot; the execution of the program, rather than letting the real processor read it directly. Because of this difference, you suddenly don't have to worry about &quot;portability&quot; anymore: you're always running on the same type of (fake) hardware! In many ways, this changes what a programmer can and should do; from asking the processor what an object's structure is <em>really</em> like (known as &quot;reflection&quot;, which is pratically impossible to do in the other languages) to simply sending the bytecode rather than the source code (written in C#) to people who want to use your program on very different computers or operating systems.</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
	<div class="answer" data-handle="d7qtssb">
		<a class="author" href="https://www.reddit.com/user/juckfungling" target="_blank">juckfungling</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>Before we get into it, I have to apologize for two things. First, I'm pretty dumb, so I have to bring it down to my level, and sorry for that. Second, putting computer code into Reddit gets some weird results, so sorry for the strange bold/indented stuff below (EDIT: I think it's fixed...?).</p>
<p>The most basic program is a Hello World program. The whole purpose of this program is to put &quot;Hello World&quot; on the screen. It might not seem like much, and it's usually just a way for a student to make sure that they can actually code on the computer that they're working on. For our purposes here, though, it's also good for comparing the complexity of those programs.</p>
<p>Computers understand binary (ie: 0s and 1s). To do a Hello World program in binary, you have to do something like this...</p>
<hr />
<pre><code>00000000  7f 45 4c 46 01 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  02 00 03 00 01 00 00 00  80 80 04 08 34 00 00 00  |............4...|
00000020  c8 00 00 00 00 00 00 00  34 00 20 00 02 00 28 00  |........4. ...(.|
00000030  04 00 03 00 01 00 00 00  00 00 00 00 00 80 04 08  |................|
00000040  00 80 04 08 9d 00 00 00  9d 00 00 00 05 00 00 00  |................|
00000050  00 10 00 00 01 00 00 00  a0 00 00 00 a0 90 04 08  |................|
00000060  a0 90 04 08 0e 00 00 00  0e 00 00 00 06 00 00 00  |................|
00000070  00 10 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000080  ba 0e 00 00 00 b9 a0 90  04 08 bb 01 00 00 00 b8  |................|
00000090  04 00 00 00 cd 80 b8 01  00 00 00 cd 80 00 00 00  |................|
000000a0  48 65 6c 6c 6f 2c 20 77  6f 72 6c 64 21 0a 00 2e  |Hello, world!...|
000000b0  73 68 73 74 72 74 61 62  00 2e 74 65 78 74 00 2e  |shstrtab..text..|
000000c0  64 61 74 61 00 00 00 00  00 00 00 00 00 00 00 00  |data............|
000000d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000000f0  0b 00 00 00 01 00 00 00  06 00 00 00 80 80 04 08  |................|
00000100  80 00 00 00 1d 00 00 00  00 00 00 00 00 00 00 00  |................|
00000110  10 00 00 00 00 00 00 00  11 00 00 00 01 00 00 00  |................|
00000120  03 00 00 00 a0 90 04 08  a0 00 00 00 0e 00 00 00  |................|
00000130  00 00 00 00 00 00 00 00  04 00 00 00 00 00 00 00  |................|
00000140  01 00 00 00 03 00 00 00  00 00 00 00 00 00 00 00  |................|
00000150  ae 00 00 00 17 00 00 00  00 00 00 00 00 00 00 00  |................|
00000160  01 00 00 00 00 00 00 00                           |........|</code></pre>
<hr />
<p>Programming in this way is annoying.</p>
<p>People eventually tried to find a way to program that was less annoying. This led to Assembly. This is a Hello World program in Assembly.</p>
<hr />
<pre><code>section     .text
global      _start                            

_start:                                        

    mov     edx,len                        
    mov     ecx,msg                            
    mov     ebx,1                               
    mov     eax,4                           
    int     0x80                         
    mov     eax,1                     
    int     0x80                         
section     .data

msg     db  'Hello, world!',0xa        
len     equ $ - msg                             </code></pre>
<hr />
<p>This is still pretty annoying.</p>
<p>C eventually gave us this...</p>
<hr />
<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    printf("Hello, world!\n");
    return 0;
}</code></pre>
<hr />
<p>This is much better. The stdio part means &quot;standard in/out&quot; which is important for printing things to the screen. The int, void, and return are a bit more complicated to explain, but basically they allow you the potential for added functionality. For instance, you could change the &quot;void&quot; part so that the program said &quot;Hello Bob!&quot; or &quot;Hello Sue!&quot; instead of &quot;Hello World&quot; depending upon how you ran the program. You could also change the int and return parts depending upon what you wanted the program to give back to you when you ran it.</p>
<p>Still, while C is better than Assembly, it can still be pretty tough to control when you want to design complex programs. This led to C++, which let you do object-oriented programming. Now, you could do things like this...</p>
<hr />
<pre><code>if (car.gas == 0)
    car-&gt;shutdown();</code></pre>
<hr />
<p>Hopefully that code makes sense (if the car has 0 gas, then shut it down). This is just a crude example, not necessarily to show how best to program a car, but rather to show how &quot;car&quot; can work as a programmable object. To do something like this in C would involve a bit more code.</p>
<p>C++ was already quite established when C# came out. C# was an attempt by Microsoft to compete with Java.</p>
<p>Objective C was another attempt to add object-oriented programming to C. Where C++ would give you code like:</p>
<hr />
<pre><code>computerscreen-&gt;printline("Hello World!");</code></pre>
<hr />
<p>...Objective C would require something like...</p>
<hr />
<pre><code>[computerscreen printline:"Hello World!"];</code></pre>
<hr />
<p>It might seem like a silly difference, but a big part of C++'s success was that it still felt a lot like C, which was super popular at the time. That said, Objective C became very popular in the projects that adopted it, so it got its own foothold.</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
	<div class="answer" data-handle="d7qkyx1">
		<a class="author" href="https://www.reddit.com/user/killersquirel11" target="_blank">killersquirel11</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>Embedded Software Engineer here -- I deal with C on a daily basis (and occasionally use C#. It's been a decade since I've touched C++ and I've never used Objective C)</p>
<p>Others have covered the history of the languages well, so I'm just going to provide another analogy:</p>
<ul>
<li>
<p>C is like working with hand tools. You can cut with extreme precision and make intricate pieces. But it's slow if you're trying to make a huge, complex piece.</p>
</li>
<li>
<p>C++/Objective C are like working with power tools. You can't hit the high-precision stuff as easily C can, but if you're building a house wouldn't you rather have the cuts be &quot;good enough&quot; rather than waste the time dealing with something that's going to be covered by drywall anyways</p>
</li>
<li>C# is like sending the cuts and materials list off to a local woodworking shop and letting them do the cutting so you can just worry about putting the pieces together.</li>
</ul>
<hr />
<p>Here's a <a href="https://en.wikiquote.org/wiki/Bjarne_Stroustrup" target="_blank">quote</a> that sums up the difference between C and C++:</p>
<blockquote>
<p>C makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do it blows your whole leg off.</p>
</blockquote>
<p>C is currently used in just about every computing device. Linux, Windows, and Mac all <a href="http://stackoverflow.com/a/580300" target="_blank">use it</a> in their <a href="https://www.reddit.com/r/explainlikeimfive/comments/2hweac/eli5_the_difference_between_linux_unix_and/" target="_blank">Kernels</a>. It's been to <a href="http://mars.nasa.gov/MPF/mpf/faqs_general.html#computer" target="_blank">Mars</a>. It is <a href="http://spectrum.ieee.org/computing/software/the-2016-top-programming-languages" target="_blank">heavily-used</a> to this day and is not (as others here have suggested) a dying language</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
	<div class="answer" data-handle="d7qf30u">
		<a class="author" href="https://www.reddit.com/user/Tapeworm1979" target="_blank">Tapeworm1979</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>C is like the first car that came out.  It does everything but you have to work at it.  It has no roof so if you make mistake (like going out in a thunderstorm) you will get wet.  Of course you can fix that but you need to do work to add an umbrella.</p>
<p>C++ is still based on C.  Its just got additions to make life easier like a roof and maybe more gears so you can go slower or faster and save some fuel.  You still need to work at it.  Its still manual (shift stick I think in American).</p>
<p>Objective C is a car from another manufacturer, they took the original design but added other bits to it.  So its not C++ but maybe adds wider tires and rear seats and maybe automatic gears.  Over time this manufacturer borrowed from C++ and added others bits. </p>
<p>C# then is Tesla.  They came along and said that they wanted to keep the original idea but make huge changes.  It's still a car but it runs on different fuel.  They also wanted to make things easier and remove direct control by adding autopilot but allowing you to still feel comfortable with what you know.</p>
<p>Edit: Corrected bad English</p>
<p>Edit2: Someone mentioned that I imply C# is the fastest, I don't I just use Tesla as a modern, different example.  This is not typically the case and a whole different topic of conversation.</p>
<p>Edit3: Gold! Thank you kind person you have made me very happy.  To think my parents never thought my profession would pay off!</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
</div>