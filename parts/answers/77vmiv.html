<div class="answers">
	<div class="answer" data-handle="dop00xc">
		<a class="author" href="https://www.reddit.com/user/kouhoutek" target="_blank">kouhoutek</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>There are three main ways to improve a CPU.</p>
<p>First, you can make it faster, able to execute more instructions every second.  The problem is the faster you go, the hotter and sloppier the chip gets, to the point it eventually fails.</p>
<p>Next, you can make the components smaller.  The smaller the chip architecture, the more transistors you can fit into one place, and the less power the chip needs, reducing heat.</p>
<p>Finally, you can make the chip smarter.  Find ways to do things in 4 steps instead of 5, do multiple things at once, improve caching, and in general do things more efficiently.</p>
<p>Edit:  Clarified the language on the second point.</p></div>		<div class="replies-controls">
			<a class="show-replies" href="javascript:void(0)">show replies...</a>
			<a class="hide-replies" href="javascript:void(0)">hide replies...</a>
		</div>
		<div class="replies-placeholder"></div>
	</div>
	<a class="less-answers upper" href="javascript:void(0)">less answers...</a>
	<div class="answer" data-handle="dop1wsl">
		<a class="author" href="https://www.reddit.com/user/afcagroo" target="_blank">afcagroo</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>As others have pointed out, Moore's Law/Dennard Scaling have historically made part of the progress easy.  You get more/faster transistors at every generation.  (That's pretty much at an end now, though.)  The trick is then to figure out how best to use those benefits. </p>
<p>With CPUs, one of the things you can almost always depend on is making the internal cache memories larger.  The performance hit from going off-chip is so huge that you almost can't have too much cache memory.  </p>
<p>After that, it gets complicated.  One of the things that you could look at historically for CPU improvement was to look at what was going on in previous generations of mainframe and supercomputers. Microprocessors eventually put inside of a single chip the things that those systems were doing to improve performance.  </p>
<p>Another mainstay was to simply absorb functions being done by other PC motherboard components.  You didn't necessarily improve the CPU performance, but you improved the performance and cost of the motherboard as a whole, which is really the point.  </p>
<p>No matter what changes you were going to make to the CPU, one thing was constant: simulation.  No matter what changes you thought might bear fruit, the key was to build a model of your new CPU and simulate the performance under a variety of workloads.  Designing and manufacturing a new microprocessor is incredibly difficult, time-consuming, and expensive.  You want to be reasonably sure of what you're going to end up with at the end of the day. </p>
<p>Back in the day, we even used to build hardware emulators, since you could get much more done with them than software simulations. But that's not really done too much these days with super-complex chips like full microprocessors.  </p></div>		<div class="replies-placeholder"></div>
	</div>
	<div class="answer" data-handle="dooyor5">
		<a class="author" href="https://www.reddit.com/user/the-incredible-ape" target="_blank">the-incredible-ape</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>It's really complex, but the very simplified basics are: </p>
<p>1) Figuring out how to make smaller circuits on the same size chip, i.e. cram in more circuits to the same space.  (this is what was/is behind the famous Moore's Law) - this can require creating an entirely new process of etching out the circuits on the silicon wafer. </p>
<p>2) Figure out how to make the same number of circuits perform more calculations in the same amount of time (i.e. better circuits, not just more of them) - this is what is referred to as &quot;instructions per clock&quot; or IPC</p>
<p>3) Figure out how to make the circuits run faster (i.e. more GHz) without problems like overheating or random errors</p></div>		<div class="replies-placeholder"></div>
	</div>
	<div class="answer" data-handle="dopqlex">
		<a class="author" href="https://www.reddit.com/user/gamer_redditor" target="_blank">gamer_redditor</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>I would like to point out that making a device smaller and making it faster are essentially the same thing. </p>
<p>Imagine a hollow pipe of length 1 meter. You can push balls through one end and they will come out the other end after 2 seconds. </p>
<p>Now make the pipe half a meter. Now the balls can travel the pipe in 1 second. </p>
<p>Making the pipe smaller, has made it faster. That's effectively what happens in a transistor. Make the dimensions smaller and the electrons can travel through the channel faster. </p>
<p>Nowadays though, we have reached the limits of how small we can make things. You can't cut the pipe in half every time. At some point the pipe will be just a few atoms long. So new techniques must be found, like putting several pipes in parallel, increasing the speed of the balls by tilting the pipe more or reducing friction, replacing the balls with light etc. </p></div>		<div class="replies-placeholder"></div>
	</div>
	<div class="answer" data-handle="dopsvs9">
		<a class="author" href="https://www.reddit.com/user/Robsonde" target="_blank">Robsonde</a>
		<span class="qa" title="Answer">A:</span><div class="markdown"><p>People think it just about faster clock speed and smaller.</p>
<p>There is also work done to get more done per clock cycle.
For example, on an older cpu a 32bit multiple might take four clock cycles or more.
If the designers can find a way to do this in one clock cycle then you get a faster cpu even at same clock speed.</p>
<p>New instructions based on workload is also common.
For example you can now do AES encryption in a single CPU instruction.</p>
<p>In the early Pentium CPU they added MMX instructions for multimedia, things like multiple a list of memory location by a factor.
That could take a loop of 5 instructions and make one instruction.</p>
<p>In a GPU similar thing we done, if you can find a way of only processing the polygons that will be seen you can save time per frame.</p>
<p>Most of it is about optimism for the workload.</p>
<p>The other big win is in memory speeds and cache.
The less you need to go to main memory the faster things go.  So having more cache ram means faster.</p></div>		<div class="replies-placeholder"></div>
	</div>
</div>